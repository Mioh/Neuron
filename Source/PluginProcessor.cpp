/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
ApdelayAudioProcessor::ApdelayAudioProcessor():
    //m_rightDelay{DelayUnit(44100 * 5), DelayUnit(44100 * 5)},
    m_numberOfDelays(1),
    m_LeftDelayMS(20),
    m_rightDelayMS(20),
    m_leftFeedback(0.0),
    m_rightFeedback(0.0),
    m_samplerate(44100),
    m_wet(0.8)
{

    m_leftDelay = new ModulatedDelayUnit[m_numberOfDelays];
    m_rightDelay = new ModulatedDelayUnit[m_numberOfDelays];
    
}

ApdelayAudioProcessor::~ApdelayAudioProcessor()
{
    delete[] m_leftDelay;
    delete[] m_rightDelay;
    
}

//==============================================================================
const String ApdelayAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int ApdelayAudioProcessor::getNumParameters()
{
    return Parameters::NumberOfParameters;
}

float ApdelayAudioProcessor::getParameter (int index)
{
    switch (index) {
        case LeftDelayTimeMS :
            return m_LeftDelayMS;
        case RightDelayTimeMS :
            return m_rightDelayMS;
        case LeftFeedback :
            return m_leftFeedback;
        case RightFeedback :
            return m_rightFeedback;
        case DryWet :
            return m_wet;
        default:
            break;
    }
    
    
    
    return 0.0f;
}

void ApdelayAudioProcessor::setParameter (int index, float value)
{
    
    switch (index) {
        case LeftDelayTimeMS :
            m_LeftDelayMS = value;
            break;
        case RightDelayTimeMS :
            m_rightDelayMS = value;
            break;
        case LeftFeedback :
            if (value < 0) value = 0;
            if (value > 0.99) value = 0.99;
            m_leftFeedback = value;
            break;
        case RightFeedback :
            if (value < 0) value = 0;
            if (value > 0.99) value = 0.99;
            m_rightFeedback = value;
            break;
        case DryWet :
            if (value < 0) value = 0;
            if (value > 0.99) value = 0.99;
            m_wet = value;
            break;
        default:
            break;
    }
}

const String ApdelayAudioProcessor::getParameterName (int index)
{
    
    switch (index) {
        case LeftDelayTimeMS :
            return "Left Delay Time";
        case RightDelayTimeMS :
            return "Right Delay Time";
        case LeftFeedback :
            return "Left Feedback";
        case RightFeedback :
            return "Right Feedback";
        case DryWet :
            return "Dry/Wet Ratio";
        default:
            break;
    }
    return String();
}

const String ApdelayAudioProcessor::getParameterText (int index)
{
    switch (index) {
        case LeftDelayTimeMS :
            return "Left Delay Time";
        case RightDelayTimeMS :
            return "Right Delay Time";
        case LeftFeedback :
            return "Left Feedback";
        case RightFeedback :
            return "Right Feedback";
        case DryWet :
            return "Dry/Wet Ratio";
        default:
            break;
    }
    
    
    return String();
}

const String ApdelayAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String ApdelayAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool ApdelayAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool ApdelayAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool ApdelayAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool ApdelayAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool ApdelayAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double ApdelayAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int ApdelayAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int ApdelayAudioProcessor::getCurrentProgram()
{
    return 0;
}

void ApdelayAudioProcessor::setCurrentProgram (int index)
{
}

const String ApdelayAudioProcessor::getProgramName (int index)
{
    return String();
}

void ApdelayAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void ApdelayAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    for (int i = 0; i < m_numberOfDelays; i++) {
        m_rightDelay[i].clear();
        m_leftDelay[i].clear();
    }
    
    m_samplerate = sampleRate;
    
    
}

void ApdelayAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
    for (int i = 0; i < m_numberOfDelays; i++) {
        m_leftDelay[i].clear();
        m_rightDelay[i].clear();
    }
}

float processSignal(int numberOfDelays, float wet, float input,
           ModulatedDelayUnit *delayUnit, float delayMS, float samplerateMS, float feedback)
{
    float dry = (1.0f - wet);
    float output = 0.0f;
    
    
    //obtain the phasor's phase
    //obtain the value from the wavetable
    
    
    
    for (int i = 0 ; i < numberOfDelays; i++) {
        // Calculate wet signal
        output += delayUnit[i].process(delayMS * samplerateMS);
        // Send signal feedback
        delayUnit[i].write(feedback * input);
    }
    // Normalize wet signal
    output = wet * output / numberOfDelays;
    // Add dry signal
    output +=  dry * input;
    return output;
}

void ApdelayAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

  
    float* leftChannel = buffer.getWritePointer(0);
    float* rightChannel = buffer.getWritePointer(1);
    
    int blockSize = buffer.getNumSamples();
    float samplerateMS = m_samplerate * 0.001f;
    
    for(int n = 0 ; n < blockSize;++n){
        
        // Better spacial locality is achived by having seperate loops for
        // left and right channel
        leftChannel[n] = processSignal(m_numberOfDelays, m_wet, leftChannel[n],
                                       m_leftDelay, m_LeftDelayMS, samplerateMS,
                                       m_leftFeedback);
        
        rightChannel[n] = processSignal(m_numberOfDelays, m_wet,
                                        rightChannel[n], m_rightDelay,
                                        m_rightDelayMS, samplerateMS,
                                        m_rightFeedback);
    }
}

//==============================================================================
bool ApdelayAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* ApdelayAudioProcessor::createEditor()
{
    return new ApdelayAudioProcessorEditor (*this);
}

//==============================================================================
void ApdelayAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void ApdelayAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new ApdelayAudioProcessor();
}
