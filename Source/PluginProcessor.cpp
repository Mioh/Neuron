/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
ApdelayAudioProcessor::ApdelayAudioProcessor():
    m_numberOfDelays(1),
    m_MaxNumberOfDelays(16),
    m_LeftDelayMS(20.0f),
    m_rightDelayMS(20.0f),
    m_leftFeedback(0.0f),
    m_rightFeedback(0.0f),
    m_samplerate(44100.0f),
    m_wet(0.5f)
{
    
    float lfoFrequency = 0.1f;
    float diff = 0.2f;
    
    for (int i = 0; i < m_MaxNumberOfDelays ; i++) {
        
        m_leftDelay.add(new ModulatedDelayUnit(m_samplerate,
                                               lfoFrequency + diff * (float) i,
                                               OcillatorUnit::SINE,
                                               m_samplerate));
        
        m_rightDelay.add(new ModulatedDelayUnit(m_samplerate,
                                               lfoFrequency + diff * (float) i,
                                               OcillatorUnit::SINE,
                                               m_samplerate));    }
}

ApdelayAudioProcessor::~ApdelayAudioProcessor()
{
    //delete[] m_leftDelay;
    //delete[] m_rightDelay;
    
}

//==============================================================================
const String ApdelayAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int ApdelayAudioProcessor::getNumParameters()
{
    return Parameters::NumberOfParameters;
}

float ApdelayAudioProcessor::getParameter (int index)
{
    switch (index) {
        case LeftDelayTimeMS :
            return m_LeftDelayMS;
        case RightDelayTimeMS :
            return m_rightDelayMS;
        case LeftFeedback :
            return m_leftFeedback;
        case RightFeedback :
            return m_rightFeedback;
        case DryWet :
            return m_wet * 100;
        case nUnits:
            return m_numberOfDelays;
        default:
            break;
    }
    
    
    
    return 0.0f;
}

void ApdelayAudioProcessor::setParameter (int index, float value)
{
    
    switch (index) {
        case LeftDelayTimeMS :
            m_LeftDelayMS = value;
            break;
        case RightDelayTimeMS :
            m_rightDelayMS = value;
            break;
        case LeftFeedback :
            if (value < 0.0) value = 0.0;
            if (value > 99.0) value = 99.0;
            m_leftFeedback = value / 100.0;
            break;
        case RightFeedback :
            if (value < 0.0) value = 0.0;
            if (value > 99.0) value = 99.0;
            m_rightFeedback = value / 100.0;
            break;
        case DryWet :
            m_wet = value / 100.0;
            break;
        case nUnits :
            m_numberOfDelays = value;
        default:
            break;
    }
}

const String ApdelayAudioProcessor::getParameterName (int index)
{
    
    switch (index) {
        case LeftDelayTimeMS :
            return "Left Delay Time";
        case RightDelayTimeMS :
            return "Right Delay Time";
        case LeftFeedback :
            return "Left Feedback";
        case RightFeedback :
            return "Right Feedback";
        case DryWet :
            return "Dry/Wet";
        case nUnits :
            return "Number of Units";
        default:
            break;
    }
    return String();
}

const String ApdelayAudioProcessor::getParameterText (int index)
{
    switch (index) {
        case LeftDelayTimeMS :
            return "Left Delay Time";
        case RightDelayTimeMS :
            return "Right Delay Time";
        case LeftFeedback :
            return "Left Feedback";
        case RightFeedback :
            return "Right Feedback";
        case DryWet :
            return "Dry/Wet";
        case nUnits :
            return "Number of Units";
        default:
            break;
    }
    
    
    return String();
}

const String ApdelayAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String ApdelayAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool ApdelayAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool ApdelayAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool ApdelayAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool ApdelayAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool ApdelayAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double ApdelayAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int ApdelayAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int ApdelayAudioProcessor::getCurrentProgram()
{
    return 0;
}

void ApdelayAudioProcessor::setCurrentProgram (int index)
{
}

const String ApdelayAudioProcessor::getProgramName (int index)
{
    return String();
}

void ApdelayAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void ApdelayAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    for (int i = 0; i < m_MaxNumberOfDelays; i++) {
        m_rightDelay[i]->clear();
        m_leftDelay[i]->clear();
    }
    
    m_samplerate = sampleRate;
    
    
}

void ApdelayAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
    for (int i = 0; i < m_MaxNumberOfDelays; i++) {
        m_leftDelay[i]->clear();
        m_rightDelay[i]->clear();
    }
}

float processSignal(int numberOfDelays, float wet, float input,
           DelayArray &delayUnit, float delayMS, float samplerateMS, float feedback)
{
    float dry = (1.0f - wet);
    float output = 0.0f;
    float volumeRatio = 1.0f/((float) numberOfDelays);
    
    for (int i = 0 ; i < numberOfDelays; i++) {
        // Calculate wet signal
        // Allow users to change number of active delay units mid play
        // by writing to all delay units using a temporary output
        float preOutput = delayUnit[i]->process(delayMS);
        //output += delayUnit[i]->delay(delayMS * samplerateMS);
        
        // Write signal + feedback to delay buffer
        // Multiply by volume ratio as the feedback will be summed up by the next sample?
        delayUnit[i]->write(input + (feedback * preOutput));
        
        // Only output delay from active units
        if (i < numberOfDelays) {
            output += preOutput;
        }
    }
    // Normalize wet signal
    output = wet * output * volumeRatio;
    // Add dry signal
    output +=  dry * input;
    return output;
}

void ApdelayAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

  
    float* leftChannel = buffer.getWritePointer(0);
    float* rightChannel = buffer.getWritePointer(1);
    
    int blockSize = buffer.getNumSamples();
    float samplerateMS = m_samplerate * 0.001f;
    
    for(int n = 0 ; n < blockSize;++n){
        
        // Better spacial locality is achived by having seperate loops for
        // left and right channel
        leftChannel[n] = processSignal(m_numberOfDelays, m_wet, leftChannel[n],
                                       m_leftDelay, m_LeftDelayMS, samplerateMS,
                                       m_leftFeedback);
        
        rightChannel[n] = processSignal(m_numberOfDelays, m_wet,
                                        rightChannel[n], m_rightDelay,
                                        m_rightDelayMS, samplerateMS,
                                        m_rightFeedback);
    }
}

//==============================================================================
bool ApdelayAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* ApdelayAudioProcessor::createEditor()
{
    return new ApdelayAudioProcessorEditor (*this);
}

//==============================================================================
void ApdelayAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void ApdelayAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new ApdelayAudioProcessor();
}
